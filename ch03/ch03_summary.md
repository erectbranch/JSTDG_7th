#### 3장에서 설명할 것은 자바스크립트의 타입, 값, 변수

* * *

### 3.1 개요와 정의
자바스크립트는 **기본 타입**과 **객체 타입** 둘로 나뉜다. 기본 타입에는 <U>숫자, 문자, 불(boolean) 타입</U>이 있다. 

자바스크립트의 특별한 값인 **null**과 **undefined**는 기본 값이지만 숫자나 문자열, 불에 속하지 않는다. 각 값은 일반적으로 그 타입 자체로 취급해도 무방하다.

자바스크립트에서 숫자, 문자열, 불, 심벌, null, undefined 중 어느 것에도 속하지 않는 값은 모두 **객체**이다. 객체는 객체 타입의 멤버이며 프로퍼티의 집합이다. 각 프로퍼티에는 이름과 값이 있고, 이 값은 기본 값일 수도 있고 다른 객체일 수도 있다.

일반적으로 자바스크립트 **객체**는 <U>이름 붙은 값의 순서 없는 집합</U>이다. 자바스크립트에는 **특별한 객체인 배열**도 있다. <U>배열은 값의 순서 있는 집합</U>이며 각 값은 숫자로 표현된다.(이름은 없다.) 배열에 적용되는 특별한 문법도 존재하며 일반적인 객체와 구별되는 특별한 동작 방식을 갖는다.

자바스크립트는 기본적인 객체와 배열 외에도 <U>유용한 객체 타입</U>이 많다. 
* Set 객체는 값의 집합이다. 
* Map 객체는 키와 값의 연결이다. 
* 형식화 배열은 바이트 배열과 다른 이진 데이터를 연결한다. 
* RegExp 타입은 텍스트 패턴이다. 이 타입을 이용해 문자열에서 정교한 매칭, 검색, 대체 동작을 할 수 있다.
* Date 타입은 날짜와 시간을 표현하며 간단한 날짜 계산도 할 수 있다.
* Error 타입과 그 하위 타입은 자바스크립트 코드 실행 중 일어날 수 있는 에러를 가리킨다.

**자바스크립트의 함수와 클래스는 그저 문법의 일부분이라고 볼 수 없는데**, 이 점이 다른 정적 언어와의 차이점이다. 자바스크립트의 함수와 클래스는 그 자체가 값이므로 프로그램에서 조작할 수 있다. 기본 값이 아닌 다른 값과 마찬가지로 함수와 클래스도 특별한 객체이다.

자바스크립트 인터프리터는 자동적으로 가비지 컬렉션을 수행해 메모리를 관리한다. 따라서 자바스크립트 프로그래머는 일반적으로 객체나 다른 값을 직접 파괴하거나 할당을 해제할 필요는 없다. 프로그램에서 어떤 값을 더는 참조하지 않게 되면 인터프리터는 그 값을 다시 사용할 수 없음을 인식하고 그 값이 차지하고 있던 메모리를 자동으로 다시 확보한다. 물론 가끔 필요 이상으로 값이 참조 가능한 상태로 남아 있어, 메모리를 회수할 수 없게 될 때가 있으니 프로그래머가 신경 써야 한다.

자바스크립트는 객체 지향 프로그래밍 스타일을 지원한다. 대략적으로 말하면 함수가 다양한 타입의 값을 다루는 것이 아니다 **객체(타입 자체)에 그 값을 다루는 메서드를 정의**한다.
예를 들어 배열 a의 요소를 정렬할 때, a를 sort() 함수에 전달하지 않는다. 대신 다음과 같이 a의 sort() 메서드를 호출한다.

a.sort();       // sort(a)와 객체 지향 버전

엄밀히 말해 자바스크립트에서는 오직 객체와 메서드를 가질 수 있다.  하지만 숫자, 문자열, 불, 심벌도 마치 메서드가 있는 것처럼 동작한다. 자바스크립트에서 메서드를 호출할 수 없는 값은 null과 undefined뿐이다.

자바스크립트의 **객체 타입은 가변(mutable)**이며, **기본 타입은 불변(immutable)**이다. 가변 타입의 값은 바뀔 수 있다. 자바스크립트 프로그램은 객체 프로퍼티와 배열 요소의 값을 바꿀 수 있다. 하지만 기본 타입인 숫자, 불, 심벌과 null, undefined은 불변이다. 문자열을 문자의 배열이라 생각하면 바꿀 수 있을 것이라 생각할 수 있지만 자바스크립트의 문자열은 불변이다. 인덱스를 통해 문자열에 들어있는 텍스트에 접근할 수는 있지만, 기존 문자열의 텍스트를 바꿀 수는 없다.

자바스크립트는 값의 타입을 자유롭게 변환한다. 예를 들어 프로그램에서 문자여링 와야 할 곳에 숫자를 쓰면 자바스크립트는 자동으로 그 숫자를 문자여롤 변환한다. 또한 불이 와야 할 곳에 불이 아닌 값이 들어갈 때도 타입을 적절하게 변환한다. 

프로그램에서는 상수와 변수의 이름을 통해 값을 참조한다. 상수는 **const**로 선언하고 변수는 **let**으로 선언한다.(오래된 자바스크립트 코드에서는 **var**로 선언한다.) 자바스크립트의 **상수와 변수에는 '타입이 없다'**. 


### 3.2 숫자
자바스크립트의 숫자 타입인 Number는 정수와 함께 실수를 대략적으로 표현한다. IEEE 754에서 정의하는 64비트 부동 소수점 형식을 사용해 숫자를 표현하는데, 배열 인덱싱이나 비트 연산자 등은 32비트 정수를 사용한다. 

자바스크립트 프로그램에 직접 기입한 숫자를 숫자 **리터럴**이라고 부른다. 

#### 3.2.1 정수 리터럴

0
3
10000000

자바스크립트는 10진 정수 리터럴뿐 아니라 16진수 값도 인식한다. 16진수 리터럴은 0x 혹은 0X로 시작하며 그 뒤에 16진수 숫자를 쓴다.

0xff        // => 256
0xBADCAFE   // => 195939070

ES6 이후 버전에서는 0b(0B)를 앞에 붙여 2진수, 0o(0O)를 앞에 붙여 8진수 정수를 표현할 수 있다.

0b10101     // => 21
0o377       // => 255

> 숫자 리터럴 안에 밑줄(_)을 써서 리터럴을 읽기 쉽게 나눠 쓸 수 있다.<br>
> let billion = 1_000_000_000;
> let bytes = 0x89_AB_CD_EF;
> let bits = 0b0001_1101_0111;
> let fraction = 0.123_456_789;

#### 3.2.2 부동 소수점 리터럴
정수 부분, 소수점, 소수점 아래 부분을 순서대로 쓴다.
부동 소수점 리터럴은 지수 표기법으로도 표현할 수 있는데, 실수 다음에 e(E)를 쓰고 그 뒤에 선택 사항인 플러스 또는 마이너스 기호, 마지막으로 지수를 나타내는 정수를 쓴다. 이 표기법은 실수에 10의 지수 승을 곱하는 방식으로 표현한다

3.14
2345.6789
.3333333333333
6.02e23         // 6.02 x $10^{23}$
1.473822E-32    // 1.473822 x $10^{-32}$


#### 3.2.3 자바스크립트의 산술 연산자
덧셈의 +, 뺄셈의 -, 곱셈의 *, 나눗셈의 %. ES2016에서 지수의 **가 추가됨.

Math.pow(2,53)      // => 2의 53승

Math.round(.6)      // => 1.0: 가장 가까운 정수로 반올림

Math.ceil(.6)       // => 1.0: 정수로 올림

Math.fllor(.6)      // => 0.0: 정수로 내림

Math.abr(-5)        // => 5: 절댓값

Math.max(x,y,z)     // 인자 중 가장 큰 값을 반환

Math.min(x,y,z)     // 가장 작은 인자를 반환

Math.random()       // 0 이상 1.0 미만의 랜덤한 숫자 x

Math.PI             // π

Math.E              // e: 자연 로그의 밑

Math.sqrt(3)        // 3**0.5

Math.pow(3, 1/3)    // 3**(1/3

Math.sin(0)         // 삼각함수. Math.cos, Math.atan 등도 있다.

Math.log(10)        // 10의 자연 로그

Math.log(100)/Math.LN10   // 100의 상용 로그

Math.log(512)/Math.LN2    // 100의 이진 로그

Math.exp(3)               // Math.E의 세제곱

아래는 ES6에서 Math 객체에 추가된 함수

Math.cbrt(27)       // => 3: 세제곱근

Math.hypot(3, 4)    // => 5: 인자의 제곱의 합의 제곱근

Math.log10(100)     // => 2: 상용 로그

Math.log2(1024)     // => 10: 이진 로그

Math.log1p(x)       // => 1+x의 자연로그, x가 아주 작아야 정확하다.

Math.expm1(x)       // Math.exp(x)-1: Math.log1p()의 역

Math.sign(x)        // 인자의 부호에 따라 -1, 0, 1을 반환한다.

Math.imul(2,3)      // => 6: C 언어의 방식을 차용한 32비트 정수의 곱셈

Math.clz32(0xf)     // => 28: 32비트 정수에서 맨 앞의 0비트 개수

Math.trunc(3.9)     // => 3: 소수점 아래를 잘라 내어 정수로 반환

Math.fround(x)      // 가장 가까운 32비트 부동 소수점 숫자로 반올림

Math.sinh(x)        // 하이퍼볼릭 사인. Math.cosh(), Math.tanh()도 있다.

Math.asinh(x)       // 하이퍼볼릭 아크사인. Math.acosh(), Math.atanh()도 있다.

자바스크립트는 산술 연산 과정에서 0으로 나누거나 오버플로, 언더플로가 발생해도 에러를 일으키지 않는다. 계산 결과가 자바스크립트가 표현할 수 있는 가장 큰 숫자보다 큰 경우(오버플로) 특별한 값 Infinity를 반환한다. 마찬가지로 음수의 절댓값이 자바스크립트가 표현할 수 있는 가장 큰 음수의 절댓값보다 크다면 결과는 음의 무한대인 -Infinity이다. 무한한 값에 다른 숫자를 더하거나, 빼거나, 곱하거나, 나누더라도 결과는 여전히 무한한 값이다.(부호는 바뀔 수 있다.)

계산 겨로가가 자바스크립트가 표현할 수 있는 가장 작은 숫자보다도 0에 가까울 경우 언더플로가 발생한다. 이 경우 0을 반환한다. 음수에서 언더플로가 발생하면 '음의 0'이라는 특별한 값을 반환한다.

한 가지 예외로 0을 0으로 나누는 경우는 정의되어 있지 않으므로 이 결과는 NaN(숫자가 아님)이다. 

// 다음 Number 프로퍼티는 ES6에서 정의하였다.

Number.parseInt()       // 전역 함수 parseInt()와 동일하다.

Number.parseFloat()     // 전역 함수 parseFloat()와 동일하다.

Number.isNaN(x)         // x는 NaN인가?

Number.isFinite(x)      // x는 유한한 숫자인가?

Number.isInteger(x)     // x는 정수인가?

Number.isSafeInteger(x) // x는 -($2^{53}$)보다 크고 $2^{53}$보다 작은 정수인가?

Number.MIN_SATE_INTEGER // -($2^{53}$ - 1)

Number.MAX_SAFE_INTEGER // ($2^{53}$) - 1

Number.EPSILON          // ($2^{-52}$): 숫자를 구별할 수 있는 가장 작은 차이 

NaN 값은 자기 자신을 포함해 어떤 값도 같지 않다는 특정이 있다. 즉 x 변수 값이 NaN인지 알아보기 위해 x === NaN 같은 표현식을 쓸 수 없다. x != x 또는 Number.isNaN(x)를 써야 한다.

#### 3.2.4 이진 부동 소수점 숫자와 반올림 오류
자바스크립트를 비롯해 최신 프로그래밍 언어에서 사용하는 IEEE 754 부동 소수점 표현은 이진 표현이며 1/2, 1/8, 1/1024 같은 분수는 정확히 표현할 ㅅ 있다. 불행히도 1/10, 1/100과 같이 자주 쓰는 분수는 정확하게 표현하지 못한다.

let x = .3 - .2;        // 0.3 빼기 0.2
let y = .2 - .1;        // 0.2 빼기 0.1
x === y                 // => false: 두 값은 같지 않다!
x === .1                // => false
y === .1                // => false

#### 3.2.6 날짜와 시간

let timestamp = Date.now();     // 현재 시간을 타임스탬프(숫자) 형식으로 표시한다.

let now = new Date();           // 현재 시간을 Date 객체로 표시한다.

les ms = now.getTime();         // 밀리초 타임스탬프로 변환한다.

let iso = now.toISOString();    // 표준 형식의 문자열로 변환한다.


### 3.3 텍스트
자바스크립트에서 텍스트를 표현하는 타입은 문자열이다. 문자열은 16비트 값이 순서에 따라 이어진 형태이며, 기본 값이므로 불변이다. 각 값은 일반적으로 유니코드 문자이다. 문자열의 길이(length)는 그 문자열에 포함된 16비트 값의 개수이다. 자바스크립트 문자열과 그 배열 형태의 위치(인덱스)는 0에서 시작한다. 16비트 값 하나를 표현하려면 그냥 길이가 1인 문자열을 쓰면 된다.

let euro = "€";

let love = "💙";

euro.length         // => 1:이 문자는 16비트 요소 하나.

love.length         // => 2: 💙의 UTF-16 인코딩은 \ud83d\udc99이다.

#### 3.3.1 문자열 리터럴
문자열을 사용할 때는 그 문자열을 앞뒤가 맞는 작은따옴표('), 큰따옴표("), 백틱(`) 쌍으로 묶으면 된다. 작은따옴표로 감싼 문자열 안에 큰따옴표나 백틱을 쓸 수 있다.

// 두 행을 한 행에 표현하기:\n을 넣기 
'two\nlines'

// 한 행을 세 행으로 나눠 쓰기: 각 행 마지막에 역슬래시(\)를 넣어 여러 행으로 구분
"one\
long\
line"

// 두 행 문자열을 두 행에 나눠 쓰기
'이 행의 마지막에 있는 줄바꿈 문자는
있는 그대로의 문자열의 일부입니다.'

클라이언트 사이드 자바스크립트 프로그래밍에서는 자바스크립트 코드에 HTML 문자열이 들어갈 수 있고, HTML 안에 자바스크립트 코드가 들어갈 수 잇다. 따라서 자바스크립트와 HTML을 섞어 쓸 때는 따옴표를 구분하는 규칙을 정해두는 게 좋다.

```Javascript
<button onclick="alert('Thank you')">Click Me</button>
```

#### 3.3.2 문자열 리터럴 안의 이스케이프 시퀸스
자바스크립트 문자열에서 역슬래시는 특별한 의미를 갖는다. 특정 문자와 조합해서 일반적인 방법으로는 문자열에 표시할 수 없는 문자를 표현한다.

#### 3.3.3 문자열 다루기
자바스크립트에는 문자열을 '병합(연결)'하는 기능이 내장되어 있다. + 연산자를 숫자와 함께 쓰면 이 연산자는 숫자를 더한다. + 연산자를 문자열에 쓰면 두 번째 문자열을 첫 번째 연산자 뒤에 이어 붙인다.

let mst = "Hello, " + "world";      // 문자열 "Hello, world"

let greeting = "Welcome to my blog," + " " + name;

문자열을 비교할 때는 일치 연산자 ===와 불일치 연산자 !==가 표준이다. 두 문자는 정확히 같은 16비트 값의 연속으로 이루어졌을 때만 일치한다.

문자열의 길이, 즉 그 안에 포함된 16비트 값의 개수는 length 프로퍼티로 알 수 있다.

s.length

자바스크립트에는 length 프로퍼티 외에도 다양한 문자열 API가 있다.

let s = "Hello, world";

// 문자열의 일부를 가져온다.
s.substring(1,4)        // => "ell"

s.slice(1,4)            // => "ell"

s.slice(-3)             // => "rld"

s.split(", ")           // => ["Hello", "world"]: 구분자를 기준으로 나눈다.

// 문자열 검색
s.indexOf("l")          // => 2: l이 처음 나타나는 위치
s.indexIf("l", 3)       // => 3: 3번 문자부터 시작해 l이 처음 나타나는 위치
s.inderOf("zz")         // => -1: 들어있지 않은 문자열
s.lastIndexOf("l")      // => 10: l이 마지막으로 나타나는 위치

// 불을 반환하는 검색 함수(ES6 추가)
s.startsWith("HELL")    // => true: s는 Hell로 시작
s.endsWith("!")         // => false: s는 !로 끝나지 않는다  
s.includes("or")        // => true: s에는 or이 들어 있다

// 문자열을 변경한다.
s.replace("llo", "ya")  // => "Heya, world"
s.toLowerCase()         // => "hello, world"
s.toUpperCase()         // => "HELLO, WORLD"
s.normalize             // 유니코드 NFC 정규화
s.normalize("NFD")      // NFD 정규화. NFKC, NFKD도 있다.

// 문자열의 각 16비트 문자를 검사
s.charAt(0)             // => "H": 첫 번째 문자
s.charAt(s.length-1)    // => "d": 마지막 문자
s.charCodeAt(0)         // => 72: 주어진 위치의 16비트 숫자
s.codePointAt(0)        // => 72: 16비트보다 큰 코드 포인트에서 동작

// 패딩 함수 (ES2017에서 추가됨)
"x".padStart(3)         // => "   x": 왼쪽에 스페이스 세 개 추가
"x".padEnd(3)           // => "x   "
"x".padStart(3, "*")    // => "**x": *를 왼쪽에 붙여 길이를 3으로 맞춘다
"x".padEnd(3, "-")      // => "x--"

// 공백 제거
" test ".trim()         // => "test": 앞뒤 공백을 제거
" test ".trimStart()    // => "test "
" test ".trimEnd()      // => " test"

// 그 외에 문자열 메서드
s.concat("!")           // => "Hello, world!": + 연산자를 쓰는 게 더 간단.
"<>".repeat(5)          // => "<><><><><>"

#### 3.4 템플릿 리터럴
ES6부터는 백틱으로 감싼 문자열 리터럴을 이용할 수 있다. 이것은 일반적인 문자열 리터럴 문법과는 다르게 임의의 자바스크립트 표현식을 넣을 수 있는 템플릿 리터럴이다. 그 안에 포함된 표현식을 평가하여 그 표현식의 값을 문자열로 변환한 다음, 변환된 문자열을 백틱 안에 들어 있는 리터럴 문자와 결합한 값으로 결정된다.

let name = "Bill";

let greeting = `Hello ${ name }.`;     // greeting == "Hello Bill."

\${} 안에 있는 것은 모두 자바스크립트 표현식으로 해석된다. 템플릿 리터럴 안에 쓸 수 있는 표현식 개수에는 제한이 없으며, 특별한 이스케이프 없이 몇 행에 걸쳐서 써도 무방하다.

```Javascript
let errorMessage = '\
\u2718 Test failure at ${filename}:${linenumber}:
${exception.message}
Stack trace:
${exception.stack}
`;
```
위 예제의 첫 번째 행 마지막에 있는 역슬래시는 줄바꿈 문자를 이스케이프하므로 결과 문자열은 줄바꿈 없이 유니코드 ✘ 문자(\u2718)로 시작한다.

#### 태그된 템플릿 리터럴
템플릿 리터럴에는 강력하지만 잘 사용되지 않는 기능이 하나 있다. 백틱 바로 앞에 함수 이름(태그)가 있다면 템플릿 리터럴의 텍스트와 표현식 값이 함수에 전달된다. 그리고 이 '태그된 템플릿 리터럴'의 값이 함수의 반환 값이다. 이 기능은 예를 들어 HTML이나 SQL을 텍스트에 붙이기 전에 이스케이프 하는 용도로 사용할 수 있다.
 
 ES6에는 내장된 태그 함수 String.raw()가 있다. 이 함수는 역슬래시 이스케이프를 처리하지 않고 백틱 안의 텍스트를 반환한다.

```Javascript
 `\n`.length                // => 1: 이 문자열에는 뉴라인 문자 하나만 있다.
 String.raw`\n`.length      // => 2: 역슬래시 문자와 n
```

이처럼 태그된 템플릿 리터럴의 태그 부분이 함수임에도 불구하고 괄호 없이 호출되었다. 여기에서는 백틱 문자가 여닫는 괄호를 대신한 것.

#### 3.3.5 패턴 매칭
자바스크립트에는 문자열 내부 패턴을 정의하고 매칭하는 정규 표현식(RegExp)이라는 데이터 타입이 있다. 
정규 표현식 리터럴은 슬래시 한 쌍 사이에 텍스트를 쓰는 형태이다.

```Javascript
/^HTML^/;               // 문자열이 시작 부분에 있는 H T M L에 일치한다.
/[1-9][0-9]*/;          // 0이 아닌 숫자가 하나 있어야 하고 그 뒤의 숫자는 제한이 없다.
/\bjavascript\b/i;      // javascript가 한 단어로 들어가야 하고 대소문자를 구분하지 않는다.
```

또 다른 예제

let text = "testing: 1, 2, 3";

let pattern = /\d+/g;       // 연속된 숫자 패턴에 일치한다.

pattern.test(text)          // => true: 패턴에 맞는 것이 있다.

text.search(pattern)        // => 9: 첫 번째로 일치하는 부분의 위치

text.match(pattern)         // => ["1", "2", "3"]: 일치하는 부분이 모두 포함된 배열

text.replace(pattern, "#")  // => "testing: #, #, #"

text.split(/\D+/)           // => ["", "1", "2", "3"]: 숫자 아닌 것에서 나눈다.


### 3.4 불 값
단 두 가지 값만 존재한다. 바로 예약어인 true와 false이다.

a === 4

위 코드는 변수 a의 값이 숫자 4와 일치하는지 검사한다. 일치하면 true, 일치하지 않는다면 false이다.

불 값은 제어문에서 자주 사용된다. 예를 들어 if/else 문은 불 값이 ture일 때 한 가지 행동을 취하고, false일 때 다른 행동을 취한다.

if (a === 4) {
    b = b + 1;
}   else {
    a = a + 1;
}

자바스크립트 값은 모두 불 값으로 변환될 수 있다. 다음 값은 모두 false로 변환되며, 따라서 false처럼 동작한다. 

undefined

null

0

-0

NaN

""      // 빈 문자열

객체와 배열을 포함해 다른 값은 모두 true로 반환되며 true로 동작한다. 자바스크립트에서 불 값을 예상하는 곳에서 false 같은 값은 false처럼 동작하고 true 같은 값은 true처럼 동작한다.

예를 들어 변수 o는 객체 또는 null 값이 할당된다고 하자. 다음과 같이 o가 null인지 명시적으로 확인하는 if 문을 쓸 수 있다.

if (o !== null) ...

위 일치 연산자는 o와 null을 비교해 true나 false로 평가한다. null이 false 같은 값이라는 점을 이용해 다음과 같이 비교를 생략할 수 있다.

if (o) ...

일치 연산자가 들어간 경우 o가 null이 아닐 때만 if의 바디가 실행된다. 하지만 아래 예제는 false, 혹은 false 같은 값이 아니면 if의 바디가 실행된다.

불 값에는 "true"나 "false" 문자열로 변환할 수 있는 toString() 메서드가 있지만 그 외에 유용한 메서드는 없다.

API는 단순한 편이지만 세 가지 중요한 불 연산자가 있다. && 연산자는 불 AND 연산을 수행한다. || 연산자는 불 OR 연산을 수행한다. 마지막으로 ! 연산자는 불 NOT 연산을 수행한다. 이 연산자는 피연산자가 false 같은 값이면 true로, true 같은 값이면 false로 평가한다.

if ((x === 0 && y === 0) || !(z === 0)) {
    // x와 y가 모두 0이거나 z가 0이 아닐 때
}


#### null과 undefined
null은 값이 없음을 나타낼 때 사용하는 특별한 값이다. null에 typeof 연산자를 사용하면 문자열 "object"를 반환하는데, 이로 미루어 null은 "객체가 없다"는 것을 나타내는 특별한 객체 값이라고 볼 수 있다. 하지만 현실에서 null은 해당 타입의 유일한 멤버로 인식되며, 객체뿐 아니라 숫자나 문자열에도 '값이 없다'는 의미로 사용할 수 있다.

undefined는 좀 다른 의미에서 값이 없음을 의미한다. 이 값은 초기화되지 않은 변수의 값이며 존재하지 않는 객체 프로퍼티나 배열 요소에 접근했을 때 반환하는 값이다. 또한 값을 명시적으로 반환하지 않는 함수의 반환 값이며, 전달되지 않는 인자의 값이기도 하다. undefined는 미리 정의된 전역 상수이며, 그 값은 undefined로 초기화된다. undefined에 typeof 연산자를 적용하면 문자열 "undefined"를 반환한다.

동등 연산자 ==는 두 값이 동등하다고 간주하고, 일치 연산자 ===는 두 값을 구분한다. null과 undefined는 모두 프로퍼티나 메서드가 없다. 이들 중 하나를 변수나 프로퍼티에 할당하거나 함수와 주고받아야 한다면 보통 null을 사용한다.


### 3.6 심벌
심벌(Symbol)은 문자열이 아닌 프로퍼티 이름. 심벌을 이해하기 위해서는 자바스크립트의 객체 타입이 프로퍼티의 순서 없는 집합이며 각 프로퍼티에 이름과 값이 있다는 것을 이해해야 한다. 프로퍼티 이름은 일반적으로 문자열이지만, ES6 이후에는 심벌 역시 같은 목적으로 사용할 수 있다.

let strname = "string name";      // 프로퍼티 이름에 문자열을 사용

let symname = Symbol("propname"); // 프로퍼티 이름에 심벌을 사용

typeof strname                    // => "string": 문자열이다

typeof symname                    // => "symbol": 심벌이다

let o = {};                       // => 새 객체를 생성

o[strname] = 1;                   // 문자열 이름으로 프로퍼티를 정의

o[symname] = 2;                   // 심벌 이름으로 프로퍼티를 정의

o[strname]                        // => 1

o[symname]                        // => 2

심벌 타입에는 리터럴 문법이 없다. 심벌 값을 가져올 때는 Symbol() 함수를 호출한다. 이 함수는 절대 같은 값을 반환하지 않으며, 같은 인자로 호출하더라도 다른 값을 반환한다. Symbol()을 호출해 심벌 값을 얻었다면 객체의 기본 프로퍼티를 같은 이름으로 덮어 쓸 염려 없이 그 값을 프로퍼티 이름으로 추가할 수 있다는 뜻이다.

Symbol() 함수는  선택 사항인 인자로 문자열을 받고 고유한 심벌 값을 반환한다. 문자열 인자를 전달하면 그 문자열은 심벌의 toString() 메서드 결과에 포함된다. 하지만 같은 문자열을 전달해 Symbol()을 다시 호출하도 그 결과는 완전히 다른 값이다.

let s = Symbol("sym_x")
s.toString                  // => "Symbol(sym_x)"


### 3.7 전역 객체
전역 객체는 일반적인 자바스크립트 객체지만 아주 중요한 목적에 쓰인다. 이 객체의 프로퍼티는 전역으로 정의된 식별자이며 모든 자바스크립트 프로그램에 사용할 수 있다. 자바스크립트 인터프리터를 시작할 때마다(또는 웹 브라우저가 새 페이지를 로드할 때마다) 다음과 같은 프로퍼티를 가진 새 전역 객체를 생성한다.

* undefined, Infinity, NaN 같은 전역 상수
* isNaN(), parseInt(), eval() 같은 전역 함수
* Date(), RegExp(), String(), Object(), Array() 같은 생성자 함수
* Math와 JSON 같은 전역 객체

전역 객체의 초기 프로퍼티는 예약어가 아니지만 에약어로 간주해야 한다. 

노드의 전역 객체에는 이름이 global인 프로퍼티가 있으며 그 값은 전역 개체 자체이다. 따라서 노드 프로그램에서는 항상 global이라는 이름으로 전역 객체를 참조할 수 있다.


### 3.8 불변인 기본 값과 가변인 객체 참조
undefined, null, 불, 숫자, 문자열 같은 기본 값과 객체(배열, 함수) 사이에는 아주 기본적인 차이가 있다. 기본 값은 불변이며 '변경'하는 방법은 없다. 숫자와 불에서는 이 사실이 명백해 보인다. 3을 2로 바꿀 수 없는 노릇이기 때문이다. 

하지만 문자열에서는 그만큼 명백하지 않다. 문자열은 문자의 배열이므로 특정 인덱스의 문자열을 바꿀 수 있을 것이라 생각할 수 있다. 하지만 자바스크립트는 이를 허용하지 않으며, 몇몇 메서드가 수정된 문자열을 반환하는 것으로 보이지만 사실 새 문자열을 반환하는 것이다.

let s = "hello";        
s.toUpperCaser();       // HELLO를 반환하지만 s는 그대로이다.
s                       // => "hello"

기본 값은 또한 값으로 비교한다. 두 값이 일치하려면 값이 같아야 한다. 위와 마찬가지로 문자열에서는 명백해 보이지 않는다. 자바스크립트에서는 두 개의 문자열 값을 비교할 때 두 문자열의 길이가 같고 각 인덱스마다 같은 문자가 있어야 같은 것으로 취급한다. 

반대로 객체는 기본 값과 다르다. 먼저 객체는 가변이므로 값을 바꿀 수 있다.

let o = { x: 1};        // 객체

o.x = 2;                // 프로퍼티 값을 바꿔 객체를 변경

o.y = 3;                // 새 프로퍼티를 추가하려 다시 변경


let a = [1,2,3]         // 배열 역시 가변이다

a[0] = 0;               // 배열 요소의 값을 변경한다

a[3] = 4;               // 배열에 새 요소를 추가한다.

객체는 값으로 비교하지 않는다. 두 객체의 프로퍼티와 값이 같다고 해서 같은 객체는 아니다. 또한 두 배열에 같은 요소가 같은 순서로 존재해도 둘은 같은 배열이 아니다.

let o = {x: 1}, p = {x: 1}; // 프로퍼티가 같은 두 객체

o === p                     // => false: 별개의 두 객체가 일치할 수는 없다

let a = [], b = [];         // 별개인 두 빈 배열

a === b                     // => false: 별개의 두 객체가 일치할 수는 없다

객체는 기본 타입과 구별하기 위해 **참조 타입**이라고 부를 때도 있다. 이 용어는 객체 값은 참조이며, 객체는 참조로 비교한다는 뜻이다. 두 객체 값이 같다는 말은 오직 두 값이 같은 객체를 참조할 때만 성립한다.

let a = [];                 // 변수 a는 빈 배열을 가리킨다

let b = a;                  // 이제 변수 b도 같은 배열을 가리킨다.

b[0] = 1;                   // b가 참조하는 배열을 변경한다.

a[0]                        // => 1: 바뀐 부분은 변수 a를 통해서도 보인다

a === b                     // => true: a와 b 모두 같은 객체를 참조하므로 같은 값이다

따라서 객체나 배열의 사본을 만들기 위해서는 **반드시 객체 프로퍼티나 배열 요소를 직접 복사해야 한다.**

```Javascript
let a = ["a", "b", "c"];;           // 복사할 배열

let b = [];                         

for(let i = 0; i < a.length; i++) { // a의 각 인덱스에 대해
    b[i] = a[i];                    // a의 요소를 b에 복사한다
}

let c = Array.from(b)               // ES6에서는 Array.from()으로 배열을 복사할 수 있다.
```

마찬가지로 별개의 객체나 배열을 비교할 때는 양쪽의 프로퍼티나 요소를 비교해야 한다. 다음은 배열을 비교하는 함수 코드이다.

```Javascript
function equalArrays(a, b) {
    if (a === b) return true;                   // 같은 배열을 참조한다면 일치
    if (a.length !== b.length) retrun false;    // 크기가 다르면 불일치
    for(let i = 0; i < a.length; i++) {         // 요소를 순회해서
        if (a[i] !== b[i]) return false;        // 하나라도 다르면 불일치
    }
    return true;                                // 모두 같다면 일치
}
```


### 3.9 타입 변환
자바스크립트는 값의 타입을 강제 하지 않는다. 하지만 변환이 성공적이지 않다면 NaN으로 바꾼다.

10 + " objects"     // => "10 objects": 숫자 10이 문자열로 변환된다

"7" * "4"           // => 28: 두 문자열을 모두 숫자로 변환

let n = 1 -"x";     // n == NaN; 문자열 x는 숫자로 변환될 수 없다

n + " objects"      // => "NaN objects": NaN이 문자열 "NaN"으로 변환된다


#### 3.9.1 변환과 일치
자바스크립트는 두 값이 같은지 테스트하는 연산자가 두 개 있다. 일치 연산자 ===는 두 피연산자가 다른 타입이면 같지 않다고 판단하며, 동등 연산자 ==를 선택하는 것보다 거의 항상 좋다. 하지만 자바스크립트는 타입 변환이 엄격하지 않으므로 좀 더 관대한 기준을 가진 동등 연산자도 정의했다. 예를 들어 다음은 모두 true이다.

null == undefined

"0" == 0

0 == false

"0" == false


#### 3.9.2 명시적 변환
직접 명시적으로 변환하는 방법들도 있다.

Number("3")     // => 3

String(false)   // => "false": false.toString()도 같다.

Boolean([])     // => true: 빈 문자열이므로 true

또한 관용구처럼 쓰이는 타입 변환이 몇 가지 있다.

x + ""          // => String(x)

+x              // => Number(x)

x-0             // => Number(x)

!!x             // => Boolean(x): !가 두 개인 것에 주의


#### toString()과 valueOf() 메서드
모든 객체는 기본 값으로 변환할 때 사용하는 두 가지 변환 메서드를 상속한다.

toString()은 객체의 문자열 표현을 반환한다. 

({x: 1, y: 2}).toString()       // => "[object Object]:

대부분의 클래스에는 해당 클래스에 더 알맞는 toString() 메서드가 정의되어 있다.

```
[1,2,3].toString                // => "1,2,3"

(function(x) { f(x); }).toString// => "function(x) { f(x); }"

/\d+/g.toString()               // => "/\\d+/g"

let d = new Date(2020,0,1);

d.toString()                    // => "Wed Jan 01 2020 00:00:00 GMT+0900 (GMT+09:00)"
```

valueOf 메서드는 toString()만큼 명확히 정의되지는 않았다. 이 메서드는 객체를 표현하는 기본 값이 존재한다면 그 값으로 객체를 반환한다. 하지만 객체는 복합된 형태이며 대부분의 객체는 단일한 기본 값으로 표현하는 것이 불가능하기 때문에, 따라서 기본 valueOf() 메서드는 기본 값이 아니라 객체 자체를 반환한다. 

문자열, 숫자, 불의 래퍼 클래스의 valueOf() 메서드는 그냥 그 기본 값을 반환한다. 

배열, 함수, 정규 표현식은 기본 메서드를 상속한다. 이들 타입의 인스턴스에서 valueOf()를 호출하면 객체 자체를 반환한다. 

Date 클래스의 valueOf() 메서드는 날짜를 내부적으로 저장하는 형식인, 1970년 1월 1일로부터 경과된 밀리초를 반환한다.

let d = new Date(2010, 0, 1);   // 2010년 1월 1일
d.valueOf()                     // => 126227160000


#### 객체에서 기본 값으로 변환하는 알고리즘

* 문자열 선호 알고리즘은 먼저 toString() 메서드를 시도한다. toString()이 존재하지 않거나 객체를 반환한다면 자바스크립트는 valueOf() 메서드를 시도한다. 둘 다 존재하지 않는다면 TypeError가 일어난다.

* 숫자 선호 알고리즘도 문자열 선호 알고리즘과 비슷하지만, valueOf()를 먼저 시도하고, toString()을 두 번째로 시도한다.

* 선호 없음 알고리즘은 변환하는 객체의 클라스에 따라 다르게 동작한다. 객체가 Date 객체일 경우 문자열 선호 알고리즘을 사용한다. 그 외의 객체에서는 숫자 선호 알고리즘을 사용한다.



### 3.10 변수 선언과 할당
값에 이름을 부여하면 프로그램에서 그 값을 참조하고 사용할 수 있다. 이런 과정을 일반적으로 변수에 값을 할당한다고 말한다. 변수라는 용어는 새로운 값을 할당할 수 있음을 암시한다. 값에 이름을 영구히 할당할 떄는 변수 대신 상수라고 부른다.

자바스크립트 프로그램에서 변수나 상수를 쓰기 전에 반드시 선언을 먼저 해야 한다. ES6 이후에는 let과 const 키워드를 사용해 변수를 선언한다.

#### 3.10.1 let과 const를 사용한 선언

let i;

let sum;

let 문 하나에 변수 여럿을 선언할 수도 있다

let i, sum;

가능하면 변수를 선언할 때 초깃값을 할당하는 것이 좋은 프로그래밍 습관이다.

let message = "hello";

let i = 0, j = 0, k = 0;

let x = 2, y = x*x; // 직전에 선언한 변수를 이용해 초기화할 수도 있다

let 문에서 변수에 초깃값을 할당하지 않으면, 할당할 때까지 undefined로 남는다.

상수를 선언할 때는 const를 사용한다. let과 비슷하지만, const는 선언을 할 때 반드시 값을 할당해 초기화해야 한다.

const H0 = 74;          // 허블 상수 (km/s/Mpc)
const C = 299792.458;   // 진공에서의 광속 (km/s)
const AU = 1.496E8;     // 태양까지의 거리를 나타내는 천문학 단위 (km)

반드시 지켜야 할 것은 아니지만, 상수를 선언할 때는 H0나 HTTP_NOT_FOUND처럼 전부 대문자를 써서 변수와 구별하는 관습이 있다.


#### 루프를 반복할 때마다 새 값을 할당받는 루프 변수
이곳에서도 보통 let을 사용한다

for(let i = 0, len = data.length; i < len; i++) console.log(data[i]);

for(let datum of data) console.log(datum);

for(let property in object) console.log(property);

루프 안에서 바뀌지 않는 값을 선언하기 위해 const를 사용할 수도 있음.


#### 변수와 상수 스코프
변수의 스코프(scope)는 프로그램 소스 코드에서 해당 변수가 정의된 영역이다. let과 const로 선언한 변수와 상수는 블록 스코프를 가진다. 이 말은 let과 const 문이 존재하는 블록 안에서만 해당 변수와 상수가 유효하다는 뜻이다.

자바스크립트의 클래스와 함수 정의는 블록이고, if/else 문, while 루프, for 루프 등의 바디 역시 블록이다. 대략적으로 말해 중괄호 안에 변수나 상수를 선언하면 그 중괄호가 변수와 상수가 정의된 영역이다.

선언이 어떤 코드 블록에도 속하지 않고 최상위 레벨이 있을 경우 이를 전역 변수 또는 상수라고 부르며, 이는 전역 스코프를 가진다. 전통적으로 클라이언트 사이드 자바스크립트에서 전역 변수의 스코프는 그 변수가 정의된 HTML 문서이다. 즉, \<script>에서 전역 변수나 상수를 선언하면 그 변수나 상수는 해당 문서의 \<script> 요소 전체(적어도 let이나 const문이 실행된 이후에 있는 스크립트 전체)에 존재한다.


#### 반복 선언
같은 스코프에서 같은 이름으로 let이나 const 선언을 하나 이상 사용하는 것은 문법 에러이다. 

```Javascript
const x = 1;        // x를 전역 상수로 선언한다
if (x === 1) {
    let x = 2;      // 블록 안에서 다시 선언할 수 있다.
    console.log(x); // 2
}
console.log(x);     // 1: 지금은 전역 스코프에 있다
let x = 3;          // 에러. x를 다시 선언하려고 할 수 없다.(문법 에러)
```


#### var를 사용한 변수 선언
var과 let의 문법이 같지만 중요한 차이가 있다.

* **var로 선언한 변수는 블록 스코프를 가지지 않는다.** 이 변수는 얼마나 깊이 중첩됐든 관계없이 포함하는 함수 바디를 스코프로 가진다.
* 함수 바디 바깥에서 var를 사용하면 전역 변수로 선언된다. 하지만 var로 선언된 전역 변수는 전역 객체의 프로퍼티로 존재한다. 전역 객체는 .globalThis로 참조할 수 있다. 따라서 함수 바깥에서 var x = 2;는 globalThis.x = 2;와 같은 의미이다. 
* let 선언과 달리 var는 같은 변수를 몇 번이고 선언할 수 있다. var 변수는 블록 스코프가 아니라 함수 스코프를 가지기 떄문이다. 따라서 for 루프를 여러 개 쓰는 함수에서는 각 루프가 for(var i = 0; ...)로 시작하는 일이 흔하다.
* var 선언에서 가장 생소한 특징은 호이스팅(끌어올림)이다. var로 변수를 선언하면 이 선언문은 함수의 맨 위로 끌어올려진다. 변수의 초기화는 코드상의 위치에 그대로 존재하지만 정의만 하면 함수 맨 위로 올라가는 것이다. 따라서 var로 선언된 변수는 함수 어디에서든 에러 없이 사용할 수 있다.(버그의 원인이 될 수 있으므로 let으로 수정한 중요한 결점 중 하나) let은 var과 다르게 변수를 초기화하기 전에 사용하면 undefined 값이 나타나고 끝나는 것이 아니라 실제로 에러가 발생한다.




